#!/bin/sh -e
# Copyright (c) 2016 The crouton Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This is a distro-specific continuation of the prepare.sh script.

PKGEXT='rpm'
DISTROAKA='openSUSE'


# install_dist: see install() in prepare.sh for details.
install_dist() {
    local pkgs='' pkgsasdeps='' params='' asdeps=''
    while [ ! "$#" = 0 ]; do
        if [ "$1" = "--minimal" ]; then
            params='--no-recommends'
        elif [ "$1" = "--asdeps" ]; then
            asdeps='y'
        else
            break
        fi
        shift
    done
    while [ ! "$#" = 0 ]; do
        if [ "$1" = '--' ]; then
            shift
            break
        fi
        pkgs="$pkgs $1"
       shift
    done
    if [ -n "$asdeps" ]; then
        pkgsasdeps="`list_uninstalled_dist '' $pkgs`"
    fi
    zypper -q install -y $params $pkgs `list_uninstalled_dist - "$@"` || return $?
# TODO see how we can implement that reasonable with zypper
# for now we just bloat the chroot
#    if [ -n "$pkgsasdeps" ]; then
#        apt-mark auto $pkgsasdeps
#    fi
}


# install_pkg_dist: see install_pkg() in prepare.sh for details.
install_pkg_dist() {
    local params=''
    if [ "$1" = '--minimal' ]; then
        params='--no-recommends'
        shift
    fi
    if [ ! "$#" = 0 ]; then
#        rpm --nodeps -i "$@" || return $?
        zypper -q install -y $params "$@" || return $?
    fi
}


# install_dummy_dist: see install_dummy() in prepare.sh for details.
install_dummy_dist() {
    if [ "$#" = 0 ]; then
        return
    fi
    local pkgname="crouton-$1" pkgprovides="$1" requires=""
    shift
    while [ "$#" != 0 ]; do
        if [ "$1" = '--' ]; then
            shift
            break
        fi
        pkgprovides="$pkgprovides, $1"
        shift
    done
    local pkgdepends="$1"
    if [ "$#" != 0 ]; then
        shift
        while [ "$#" != 0 ]; do
            pkgdepends="$pkgdepends, $1"
            shift
        done
    fi

    if [ $pkgdepends ]; then
        requires="Requires: ${pkgdepends}"
    fi

    local tmp="`mktemp -d crouton.XXXXXX --tmpdir=/tmp`"
    addtrap "rm -rf '$tmp'"
    cat > "$tmp/dummy.spec" <<EOF
Name: $pkgname
Version: 1.0.0
Release: 1.0.0
Group: dummy
Vendor: dummy
License: %{vendor}
Provides: $pkgprovides
$requires
Summary: Provides a dummy ${pkgname#*-} for crouton
BuildRoot:      %{_tmppath}/%{name}-%{version}-build

%description
%{summary}

%files
EOF
    rpmbuild --define='_rpmdir ${tmp}' -bb ${tmp}/dummy.spec > ${tmp}/build.log
    if [ $? != 0 ]
    then
        echo "ERROR: Could not build dummy rpm!"
    fi
    pkg=$(awk '/^wrote:/ { print $2 }' < ${tmp}/build.log)
    rm ${tmp}/build.log
#    rpm --no-deps -i "$pkg"
    zypper -q install -y --force-resolution "$pkg"
}


# remove_dist: see remove() in prepare.sh for details.
remove_dist() {
    zypper -q remove -y "$@"
}


# list_uninstalled_dist: see list_uninstalled() in prepare.sh for details.
# If the package is virtual (e.g. libc-dev), we need to find the binary package
# corresponding to it (e.g. libc6-dev), so that we can remove it afterwards
# ("apt-get remove libc-dev" does not remove libc6-dev).
list_uninstalled_dist() {
    local suffix="$1" pkg
    shift
    for pkg in "$@"; do
        if ! zypper se -i "$pkg" 2>/dev/null | grep -q '^i'; then
            echo -n "$pkg$suffix "
        fi
    done
}

# detect_mirror
# Detects the current mirror: Prints the first source that provides the
# "main" component.
detect_mirror() {
#    if ! awk '/^deb .* main( .*)?$/ { print $2; f=1; exit }; END { exit !f }' \
#          /etc/apt/sources.list /etc/apt/sources.list.d/*.list 2>/dev/null; then
#        error 1 "Cannot detect mirror."
#    fi
    return
}


# install_mirror_package [--asdeps] package path [regex arch]
# Fetch and install a package directly from the mirror.
# This allows to install a package from a different release, when the current
# release does not provide the required package, or when the version it
# provides is broken or outdated.
# --asdeps: Install as dependency
# package:  Package name (e.g. xserver-xephyr)
# path:     Mirror path (e.g. pool/universe/x/xorg-server)
# regex:    Version regex (e.g. '1\.11\.4-0ubuntu[0-9][0-9]\.[0-9]*').
#           If not specified, match any version (default regex: ".*").
#           The latest version that matches the regex is selected.
#           If the package is a dependency of other packages (e.g. a library),
#           you should select the earliest version that provides the required
#           features, to prevent breakage during release upgrade.
# arch:     Additional architecture to install. e.g. i386 installs both i386
#           and amd64 packages. Defaults to only installing "$ARCH"
install_mirror_package() {
#    local asdeps=''
#    if [ "$1" = "--asdeps" ]; then
#        asdeps='y'
#        shift
#    fi
#    local package="$1"
#    # Split local and assignment to make sure -e error handling works
#    local mirror
#    mirror="`detect_mirror`"
#    local url="${mirror%/}/${2#/}/"
#    local debfiles=""
#    local pkgnames=""
#
#    for carch in "$ARCH" "$4"; do
#        if [ -z "$carch" ]; then
#            continue
#        fi
#        local pkgname="$package:$carch"
#        local regex="^${package}_${3:-.*}_(${carch}|all)\.deb$"
#        # Find package in directory listing:
#        # Filenames are HTML <a href> values, enclosed in quotes.
#        local xvers="`wget -O- "$url" -nv \
#            | awk 'BEGIN { RS="<[aA][^>]* [hH][rR][eE][fF]=\\""; FS="\\"" }
#                   NR > 1 && $1 ~ /'"$regex"'/ { print $1 }' \
#            | sort -V | tail -n 1`"
#        if [ -z "$xvers" ]; then
#            error 1 "Error retrieving $pkgname."
#        fi
#        # Check if installed version is already up to date
#        local installed="`dpkg-query -l "$pkgname" 2>/dev/null | \
#            awk '/^[hi]i/ { sub(/^[0-9]+:/, "", $3); print $2 "_" $3 }'`"
#        if [ "${xvers%_*}" = "$installed" ]; then
#            echo "$pkgname is already up to date ($installed)."
#            continue
#        fi
#        pkgurl="$url$xvers"
#        # Download the package to a temporary file
#        local deb="`mktemp crouton.XXXXXX --tmpdir=/tmp`"
#        addtrap "rm -f '$deb'"
#        wget "$pkgurl" -O"$deb"
#        debfiles="$debfiles $deb"
#        pkgnames="$pkgnames $pkgname"
#    done
#
#    if [ -n "$debfiles" ]; then
#        # Install the package
#        install_pkg $debfiles
#        if [ -n "$asdeps" ]; then
#            apt-mark auto $pkgnames
#        fi
#    fi
    return
}

if [ -r /debootstrap.sh ]; then
    # Clean contents of /var/run (since we'll always be mounting over it).
    rm -rf --one-file-system /var/run/*
fi

# enable network ping for all users
sudo chmod u+s /usr/bin/ping

# add rpmbuild for dummy packages
sudo zypper -q install -y --no-recommends rpmbuild
